.\"t
.\" Automatically generated by Pandoc 2.7.3
.\"
.TH "IRTT-CLIENT" "1" "February 11, 2018" "v0.9.0" "IRTT Manual"
.hy
.SH NAME
.PP
irtt-client - Isochronous Round-Trip Time Client
.SH SYNOPSIS
.PP
irtt client [\f[I]args\f[R]]
.SH DESCRIPTION
.PP
\f[I]irtt client\f[R] is the client for irtt(1) (irtt.html).
.SH OPTIONS
.TP
.B -d \f[I]duration\f[R]
Total time to send (default 1m0s, see Duration units below)
.TP
.B -i \f[I]interval\f[R]
Send interval (default 1s, see Duration units below)
.TP
.B -l \f[I]length\f[R]
Length of packet (default 0, increased as necessary for required
headers), common values:
.RS
.IP \[bu] 2
1472 (max unfragmented size of IPv4 datagram for 1500 byte MTU)
.IP \[bu] 2
1452 (max unfragmented size of IPv6 datagram for 1500 byte MTU)
.RE
.TP
.B -o \f[I]file\f[R]
Write JSON output to file (use `-' for stdout).
The extension used for \f[I]file\f[R] controls the gzip behavior as
follows (output to stdout is not gzipped):
.RS
.PP
.TS
tab(@);
l l.
T{
Extension
T}@T{
Behavior
T}
_
T{
none
T}@T{
extension .json.gz is added, output is gzipped
T}
T{
\&.json.gz
T}@T{
output is gzipped
T}
T{
\&.gz
T}@T{
output is gzipped, extension changed to .json.gz
T}
T{
\&.json
T}@T{
output is not gzipped
T}
.TE
.RE
.TP
.B -q
Quiet, suppress per-packet output
.TP
.B -Q
Really quiet, suppress all output except errors to stderr
.TP
.B -n
No test, connect to the server and validate test parameters but
don\[cq]t run the test
.TP
.B --stats=\f[I]stats\f[R]
Server stats on received packets (default \f[I]both\f[R]).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]none\f[R]
T}@T{
no server stats on received packets
T}
T{
\f[I]count\f[R]
T}@T{
total count of received packets
T}
T{
\f[I]window\f[R]
T}@T{
receipt status of last 64 packets with each reply
T}
T{
\f[I]both\f[R]
T}@T{
both count and window
T}
.TE
.RE
.TP
.B --tstamp=\f[I]mode\f[R]
Server timestamp mode (default \f[I]both\f[R]).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]none\f[R]
T}@T{
request no timestamps
T}
T{
\f[I]send\f[R]
T}@T{
request timestamp at server send
T}
T{
\f[I]receive\f[R]
T}@T{
request timestamp at server receive
T}
T{
\f[I]both\f[R]
T}@T{
request both send and receive timestamps
T}
T{
\f[I]midpoint\f[R]
T}@T{
request midpoint timestamp (send/receive avg)
T}
.TE
.RE
.TP
.B --clock=\f[I]clock\f[R]
Clock/s used for server timestamps (default \f[I]both\f[R]).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]wall\f[R]
T}@T{
wall clock only
T}
T{
\f[I]monotonic\f[R]
T}@T{
monotonic clock only
T}
T{
\f[I]both\f[R]
T}@T{
both clocks
T}
.TE
.RE
.TP
.B --dscp=\f[I]dscp\f[R]
DSCP (ToS) value (default 0, 0x prefix for hex).
Common values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
0
T}@T{
Best effort
T}
T{
8
T}@T{
CS1- Bulk
T}
T{
40
T}@T{
CS5- Video
T}
T{
46
T}@T{
EF- Expedited forwarding
T}
.TE
.PP
DSCP & ToS (https://www.tucny.com/Home/dscp-tos)
.RE
.TP
.B --df=\f[I]DF\f[R]
Setting for do not fragment (DF) bit in all packets.
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]default\f[R]
T}@T{
OS default
T}
T{
\f[I]false\f[R]
T}@T{
DF bit not set
T}
T{
\f[I]true\f[R]
T}@T{
DF bit set
T}
.TE
.RE
.TP
.B --wait=\f[I]wait\f[R]
Wait time at end of test for unreceived replies (default 3x4s).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Format
T}@T{
Meaning
T}
_
T{
#\f[I]x\f[R]duration
T}@T{
# times max RTT, or duration if no response
T}
T{
#\f[I]r\f[R]duration
T}@T{
# times RTT, or duration if no response
T}
T{
duration
T}@T{
fixed duration (see Duration units below)
T}
.TE
.PP
Examples:
.PP
.TS
tab(@);
l l.
T{
Example
T}@T{
Meaning
T}
_
T{
3x4s
T}@T{
3 times max RTT, or 4 seconds if no response
T}
T{
1500ms
T}@T{
fixed 1500 milliseconds
T}
.TE
.RE
.TP
.B --timer=\f[I]timer\f[R]
Timer for waiting to send packets (default comp).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]simple\f[R]
T}@T{
Go\[cq]s standard time.Timer
T}
T{
\f[I]comp\f[R]
T}@T{
Simple timer with error compensation (see -tcomp)
T}
T{
\f[I]hybrid:\f[R]#
T}@T{
Hybrid comp/busy timer with sleep factor (default 0.95)
T}
T{
\f[I]busy\f[R]
T}@T{
busy wait loop (high precision and CPU, blasphemy)
T}
.TE
.RE
.TP
.B --tcomp=\f[I]alg\f[R]
Comp timer averaging algorithm (default exp:0.10).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]avg\f[R]
T}@T{
Cumulative average error
T}
T{
\f[I]win:\f[R]#
T}@T{
Moving average error with window # (default 5)
T}
T{
\f[I]exp:\f[R]#
T}@T{
Exponential average with alpha # (default 0.10)
T}
.TE
.RE
.TP
.B --fill=\f[I]fill\f[R]
Fill payload with given data (default none).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]none\f[R]
T}@T{
Leave payload as all zeroes
T}
T{
\f[I]rand\f[R]
T}@T{
Use random bytes from Go\[cq]s math.rand
T}
T{
\f[I]pattern:\f[R]XX
T}@T{
Use repeating pattern of hex (default 69727474)
T}
.TE
.RE
.TP
.B --fill-one
Fill only once and repeat for all packets
.TP
.B --sfill=fill
Request server fill (default not specified).
See values for \[en]fill.
Server must support and allow this fill with \[en]allow-fills.
.TP
.B --local=addr
Local address (default from OS).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]:port\f[R]
T}@T{
Unspecified address (all IPv4/IPv6 addresses) with port
T}
T{
\f[I]host\f[R]
T}@T{
Host with dynamic port, see Host formats below
T}
T{
\f[I]host:port\f[R]
T}@T{
Host with specified port, see Host formats below
T}
.TE
.RE
.TP
.B --hmac=key
Add HMAC with key (0x for hex) to all packets, provides:
.RS
.IP \[bu] 2
Dropping of all packets without a correct HMAC
.IP \[bu] 2
Protection for server against unauthorized discovery and use
.RE
.TP
.B -4
IPv4 only
.TP
.B -6
IPv6 only
.TP
.B --timeouts=\f[I]durations\f[R]
Timeouts used when connecting to server (default 1s,2s,4s,8s).
Comma separated list of durations (see Duration units below).
Total wait time will be up to the sum of these Durations.
Max packets sent is up to the number of Durations.
Minimum timeout duration is 200ms.
.TP
.B --ttl=\f[I]ttl\f[R]
Time to live (default 0, meaning use OS default)
.TP
.B --loose
Accept and use any server restricted test parameters instead of exiting
with nonzero status.
.TP
.B --thread
Lock sending and receiving goroutines to OS threads
.TP
.B -h
Show help
.TP
.B -v
Show version
.SS Host formats
.PP
Hosts may be either hostnames (for IPv4 or IPv6) or IP addresses.
IPv6 addresses must be surrounded by brackets and may include a zone
after the % character.
Examples:
.PP
.TS
tab(@);
l l.
T{
Type
T}@T{
Example
T}
_
T{
IPv4 IP
T}@T{
192.168.1.10
T}
T{
IPv6 IP
T}@T{
[2001:db8:8f::2/32]
T}
T{
IPv4/6 hostname
T}@T{
localhost
T}
.TE
.PP
\f[B]Note:\f[R] IPv6 addresses must be quoted in most shells.
.SS Duration units
.PP
Durations are a sequence of decimal numbers, each with optional
fraction, and unit suffix, such as: \[lq]300ms\[rq], \[lq]1m30s\[rq] or
\[lq]2.5m\[rq].
Sanity not enforced.
.PP
.TS
tab(@);
l l.
T{
Suffix
T}@T{
Unit
T}
_
T{
h
T}@T{
hours
T}
T{
m
T}@T{
minutes
T}
T{
s
T}@T{
seconds
T}
T{
ms
T}@T{
milliseconds
T}
T{
ns
T}@T{
nanoseconds
T}
.TE
.SH OUTPUT
.PP
IRTT\[cq]s JSON output format consists of five top-level objects:
.IP "1." 3
version
.IP "2." 3
system_info
.IP "3." 3
config
.IP "4." 3
stats
.IP "5." 3
round_trips
.PP
These are documented through the examples below.
All attributes are present unless otherwise \f[B]noted\f[R].
.SS version
.PP
version information
.IP
.nf
\f[C]
\[dq]version\[dq]: {
    \[dq]irtt\[dq]: \[dq]0.9.0\[dq],
    \[dq]protocol\[dq]: 1,
    \[dq]json_format\[dq]: 1
},
\f[R]
.fi
.IP \[bu] 2
\f[I]irtt\f[R] the IRTT version number
.IP \[bu] 2
\f[I]protocol\f[R] the protocol version number (increments mean
incompatible changes)
.IP \[bu] 2
\f[I]json_format\f[R] the JSON format number (increments mean
incompatible changes)
.SS system_info
.PP
a few basic pieces of system information
.IP
.nf
\f[C]
\[dq]system_info\[dq]: {
    \[dq]os\[dq]: \[dq]darwin\[dq],
    \[dq]cpus\[dq]: 8,
    \[dq]go_version\[dq]: \[dq]go1.9.2\[dq],
    \[dq]hostname\[dq]: \[dq]tron.local\[dq]
},
\f[R]
.fi
.IP \[bu] 2
\f[I]os\f[R] the Operating System from Go\[cq]s \f[I]runtime.GOOS\f[R]
.IP \[bu] 2
\f[I]cpus\f[R] the number of CPUs reported by Go\[cq]s
\f[I]runtime.NumCPU()\f[R], which reflects the number of logical rather
than physical CPUs.
In the example below, the number 8 is reported for a Core i7 (quad core)
with hyperthreading (2 threads per core).
.IP \[bu] 2
\f[I]go_version\f[R] the version of Go the executable was built with
.IP \[bu] 2
\f[I]hostname\f[R] the local hostname
.SS config
.PP
the configuration used for the test
.IP
.nf
\f[C]
\[dq]config\[dq]: {
    \[dq]local_address\[dq]: \[dq]127.0.0.1:51203\[dq],
    \[dq]remote_address\[dq]: \[dq]127.0.0.1:2112\[dq],
    \[dq]open_timeouts\[dq]: \[dq]1s,2s,4s,8s\[dq],
    \[dq]params\[dq]: {
        \[dq]proto_version\[dq]: 1,
        \[dq]duration\[dq]: 600000000,
        \[dq]interval\[dq]: 200000000,
        \[dq]length\[dq]: 48,
        \[dq]received_stats\[dq]: \[dq]both\[dq],
        \[dq]stamp_at\[dq]: \[dq]both\[dq],
        \[dq]clock\[dq]: \[dq]both\[dq],
        \[dq]dscp\[dq]: 0,
        \[dq]server_fill\[dq]: \[dq]\[dq]
    },
    \[dq]loose\[dq]: false,
    \[dq]ip_version\[dq]: \[dq]IPv4\[dq],
    \[dq]df\[dq]: 0,
    \[dq]ttl\[dq]: 0,
    \[dq]timer\[dq]: \[dq]comp\[dq],
    \[dq]waiter\[dq]: \[dq]3x4s\[dq],
    \[dq]filler\[dq]: \[dq]none\[dq],
    \[dq]fill_one\[dq]: false,
    \[dq]thread_lock\[dq]: false,
    \[dq]supplied\[dq]: {
        \[dq]local_address\[dq]: \[dq]:0\[dq],
        \[dq]remote_address\[dq]: \[dq]localhost\[dq],
        \[dq]open_timeouts\[dq]: \[dq]1s,2s,4s,8s\[dq],
        \[dq]params\[dq]: {
            \[dq]proto_version\[dq]: 1,
            \[dq]duration\[dq]: 600000000,
            \[dq]interval\[dq]: 200000000,
            \[dq]length\[dq]: 0,
            \[dq]received_stats\[dq]: \[dq]both\[dq],
            \[dq]stamp_at\[dq]: \[dq]both\[dq],
            \[dq]clock\[dq]: \[dq]both\[dq],
            \[dq]dscp\[dq]: 0,
            \[dq]server_fill\[dq]: \[dq]\[dq]
        },
        \[dq]loose\[dq]: false,
        \[dq]ip_version\[dq]: \[dq]IPv4+6\[dq],
        \[dq]df\[dq]: 0,
        \[dq]ttl\[dq]: 0,
        \[dq]timer\[dq]: \[dq]comp\[dq],
        \[dq]waiter\[dq]: \[dq]3x4s\[dq],
        \[dq]filler\[dq]: \[dq]none\[dq],
        \[dq]fill_one\[dq]: false,
        \[dq]thread_lock\[dq]: false
    }
},
\f[R]
.fi
.IP \[bu] 2
\f[I]local_address\f[R] the local address (IP:port) for the client
.IP \[bu] 2
\f[I]remote_address\f[R] the remote address (IP:port) for the server
.IP \[bu] 2
\f[I]open_timeouts\f[R] a list of timeout durations used after an open
packet is sent
.IP \[bu] 2
\f[I]params\f[R] are the parameters that were negotiated with the
server, including:
.RS 2
.IP \[bu] 2
\f[I]proto_version\f[R] protocol version number
.IP \[bu] 2
\f[I]duration\f[R] duration of the test, in nanoseconds
.IP \[bu] 2
\f[I]interval\f[R] send interval, in nanoseconds
.IP \[bu] 2
\f[I]length\f[R] packet length
.IP \[bu] 2
\f[I]received_stats\f[R] statistics for packets received by server
(none, count, window or both, \f[I]--stats\f[R] flag for irtt client)
.IP \[bu] 2
\f[I]stamp_at\f[R] timestamp selection parameter (none, send, receive,
both or midpoint, \f[I]--tstamp\f[R] flag for irtt client)
.IP \[bu] 2
\f[I]clock\f[R] clock selection parameter (wall or monotonic,
\f[I]--clock\f[R] flag for irtt client)
.IP \[bu] 2
\f[I]dscp\f[R] the
DSCP (https://en.wikipedia.org/wiki/Differentiated_services) value
.IP \[bu] 2
\f[I]server_fill\f[R] the requested server fill (\f[I]--sfill\f[R] flag
for irtt client)
.RE
.IP \[bu] 2
\f[I]loose\f[R] if true, client accepts and uses restricted server
parameters, with a warning
.IP \[bu] 2
\f[I]ip_version\f[R] the IP version used (IPv4 or IPv6)
.IP \[bu] 2
\f[I]df\f[R] the do-not-fragment setting (0 == OS default, 1 == false, 2
== true)
.IP \[bu] 2
\f[I]ttl\f[R] the IP
time-to-live (https://en.wikipedia.org/wiki/Time_to_live) value
.IP \[bu] 2
\f[I]timer\f[R] the timer used: simple, comp, hybrid or busy (irtt
client --timer flag)
.IP \[bu] 2
\f[I]time_source\f[R] the time source used: go or windows
.IP \[bu] 2
\f[I]waiter\f[R] the waiter used: fixed duration, multiple of RTT or
multiple of max RTT (irtt client \f[I]--wait\f[R] flag)
.IP \[bu] 2
\f[I]filler\f[R] the packet filler used: none, rand or pattern (irtt
client \f[I]--fill\f[R] flag)
.IP \[bu] 2
\f[I]fill_one\f[R] whether to fill only once and repeat for all packets
(irtt client \f[I]--fill-one\f[R] flag)
.IP \[bu] 2
\f[I]thread_lock\f[R] whether to lock packet handling goroutines to OS
threads
.IP \[bu] 2
\f[I]supplied\f[R] a nested \f[I]config\f[R] object with the
configuration as originally supplied to the API or \f[I]irtt\f[R]
command.
The supplied configuration can differ from the final configuration in
the following ways:
.RS 2
.IP \[bu] 2
\f[I]local_address\f[R] and \f[I]remote_address\f[R] may have hostnames
or named ports before being resolved to an IP and numbered port
.IP \[bu] 2
\f[I]ip_version\f[R] may be IPv4+6 before it is determined after address
resolution
.IP \[bu] 2
\f[I]params\f[R] may be different before the server applies restrictions
based on its configuration
.RE
.SS stats
.PP
statistics for the results
.IP
.nf
\f[C]
\[dq]stats\[dq]: {
    \[dq]start_time\[dq]: {
        \[dq]wall\[dq]: 1528621979787034330,
        \[dq]monotonic\[dq]: 5136247
    },
    \[dq]send_call\[dq]: {
        \[dq]total\[dq]: 79547,
        \[dq]n\[dq]: 3,
        \[dq]min\[dq]: 17790,
        \[dq]max\[dq]: 33926,
        \[dq]mean\[dq]: 26515,
        \[dq]stddev\[dq]: 8148,
        \[dq]variance\[dq]: 66390200
    },
    \[dq]timer_error\[dq]: {
        \[dq]total\[dq]: 227261,
        \[dq]n\[dq]: 2,
        \[dq]min\[dq]: 59003,
        \[dq]max\[dq]: 168258,
        \[dq]mean\[dq]: 113630,
        \[dq]stddev\[dq]: 77254,
        \[dq]variance\[dq]: 5968327512
    },
    \[dq]rtt\[dq]: {
        \[dq]total\[dq]: 233915,
        \[dq]n\[dq]: 2,
        \[dq]min\[dq]: 99455,
        \[dq]max\[dq]: 134460,
        \[dq]mean\[dq]: 116957,
        \[dq]median\[dq]: 116957,
        \[dq]stddev\[dq]: 24752,
        \[dq]variance\[dq]: 612675012
    },
    \[dq]send_delay\[dq]: {
        \[dq]total\[dq]: 143470,
        \[dq]n\[dq]: 2,
        \[dq]min\[dq]: 54187,
        \[dq]max\[dq]: 89283,
        \[dq]mean\[dq]: 71735,
        \[dq]median\[dq]: 71735,
        \[dq]stddev\[dq]: 24816,
        \[dq]variance\[dq]: 615864608
    },
    \[dq]receive_delay\[dq]: {
        \[dq]total\[dq]: 90445,
        \[dq]n\[dq]: 2,
        \[dq]min\[dq]: 45177,
        \[dq]max\[dq]: 45268,
        \[dq]mean\[dq]: 45222,
        \[dq]median\[dq]: 45222,
        \[dq]stddev\[dq]: 64,
        \[dq]variance\[dq]: 4140
    },
    \[dq]server_packets_received\[dq]: 2,
    \[dq]bytes_sent\[dq]: 144,
    \[dq]bytes_received\[dq]: 96,
    \[dq]duplicates\[dq]: 0,
    \[dq]late_packets\[dq]: 0,
    \[dq]wait\[dq]: 403380,
    \[dq]duration\[dq]: 400964028,
    \[dq]packets_sent\[dq]: 3,
    \[dq]packets_received\[dq]: 2,
    \[dq]packet_loss_percent\[dq]: 33.333333333333336,
    \[dq]upstream_loss_percent\[dq]: 33.333333333333336,
    \[dq]downstream_loss_percent\[dq]: 0,
    \[dq]duplicate_percent\[dq]: 0,
    \[dq]late_packets_percent\[dq]: 0,
    \[dq]ipdv_send\[dq]: {
        \[dq]total\[dq]: 35096,
        \[dq]n\[dq]: 1,
        \[dq]min\[dq]: 35096,
        \[dq]max\[dq]: 35096,
        \[dq]mean\[dq]: 35096,
        \[dq]median\[dq]: 35096,
        \[dq]stddev\[dq]: 0,
        \[dq]variance\[dq]: 0
    },
    \[dq]ipdv_receive\[dq]: {
        \[dq]total\[dq]: 91,
        \[dq]n\[dq]: 1,
        \[dq]min\[dq]: 91,
        \[dq]max\[dq]: 91,
        \[dq]mean\[dq]: 91,
        \[dq]median\[dq]: 91,
        \[dq]stddev\[dq]: 0,
        \[dq]variance\[dq]: 0
    },
    \[dq]ipdv_round_trip\[dq]: {
        \[dq]total\[dq]: 35005,
        \[dq]n\[dq]: 1,
        \[dq]min\[dq]: 35005,
        \[dq]max\[dq]: 35005,
        \[dq]mean\[dq]: 35005,
        \[dq]median\[dq]: 35005,
        \[dq]stddev\[dq]: 0,
        \[dq]variance\[dq]: 0
    },
    \[dq]server_processing_time\[dq]: {
        \[dq]total\[dq]: 20931,
        \[dq]n\[dq]: 2,
        \[dq]min\[dq]: 9979,
        \[dq]max\[dq]: 10952,
        \[dq]mean\[dq]: 10465,
        \[dq]stddev\[dq]: 688,
        \[dq]variance\[dq]: 473364
    },
    \[dq]timer_err_percent\[dq]: 0.056815,
    \[dq]timer_misses\[dq]: 0,
    \[dq]timer_miss_percent\[dq]: 0,
    \[dq]send_rate\[dq]: {
        \[dq]bps\[dq]: 2878,
        \[dq]string\[dq]: \[dq]2.9 Kbps\[dq]
    },
    \[dq]receive_rate\[dq]: {
        \[dq]bps\[dq]: 3839,
        \[dq]string\[dq]: \[dq]3.8 Kbps\[dq]
    }
},
\f[R]
.fi
.PP
\f[B]Note:\f[R] In the \f[I]stats\f[R] object, a \f[I]duration
stats\f[R] class of object repeats and will not be repeated in the
individual descriptions.
It contains statistics about nanosecond duration values and has the
following attributes:
.IP \[bu] 2
\f[I]total\f[R] the total of the duration values
.IP \[bu] 2
\f[I]n\f[R] the number of duration values
.IP \[bu] 2
\f[I]min\f[R] the minimum duration value
.IP \[bu] 2
\f[I]max\f[R] the maximum duration value
.IP \[bu] 2
\f[I]mean\f[R] the mean duration value
.IP \[bu] 2
\f[I]stddev\f[R] the standard deviation
.IP \[bu] 2
\f[I]variance\f[R] the variance
.PP
The regular attributes in \f[I]stats\f[R] are as follows:
.IP \[bu] 2
\f[I]start_time\f[R] the start time of the test (see
\f[I]round_trips\f[R] Notes for descriptions of \f[I]wall\f[R] and
\f[I]monotonic\f[R] values)
.IP \[bu] 2
\f[I]send_call\f[R] a duration stats object for the call time when
sending packets
.IP \[bu] 2
\f[I]timer_error\f[R] a duration stats object for the observed sleep
time error
.IP \[bu] 2
\f[I]rtt\f[R] a duration stats object for the round-trip time
.IP \[bu] 2
\f[I]send_delay\f[R] a duration stats object for the one-way send delay
\f[B](only available if server timestamps are enabled)\f[R]
.IP \[bu] 2
\f[I]receive_delay\f[R] a duration stats object for the one-way receive
delay \f[B](only available if server timestamps are enabled)\f[R]
.IP \[bu] 2
\f[I]server_packets_received\f[R] the number of packets received by the
server, including duplicates (always present, but only valid if the
\f[I]ReceivedStats\f[R] parameter includes \f[I]ReceivedStatsCount\f[R],
or the \f[I]--stats\f[R] flag to the irtt client is \f[I]count\f[R] or
\f[I]both\f[R])
.IP \[bu] 2
\f[I]bytes_sent\f[R] the number of UDP payload bytes sent during the
test
.IP \[bu] 2
\f[I]bytes_received\f[R] the number of UDP payload bytes received during
the test
.IP \[bu] 2
\f[I]duplicates\f[R] the number of packets received with the same
sequence number
.IP \[bu] 2
\f[I]late_packets\f[R] the number of packets received with a sequence
number lower than the previously received sequence number (one simple
metric for out-of-order packets)
.IP \[bu] 2
\f[I]wait\f[R] the actual time spent waiting for final packets, in
nanoseconds
.IP \[bu] 2
\f[I]duration\f[R] the actual duration of the test, in nanoseconds, from
the time just before the first packet was sent to the time after the
last packet was received and results are starting to be calculated
.IP \[bu] 2
\f[I]packets_sent\f[R] the number of packets sent to the server
.IP \[bu] 2
\f[I]packets_received\f[R] the number of packets received from the
server
.IP \[bu] 2
\f[I]packet_loss_percent\f[R] 100 * (\f[I]packets_sent\f[R] -
\f[I]packets_received\f[R]) / \f[I]packets_sent\f[R]
.IP \[bu] 2
\f[I]upstream_loss_percent\f[R] 100 * (\f[I]packets_sent\f[R] -
\f[I]server_packets_received\f[R] / \f[I]packets_sent\f[R]) (always
present, but only valid if \f[I]server_packets_received\f[R] is valid)
.IP \[bu] 2
\f[I]downstream_loss_percent\f[R] 100 *
(\f[I]server_packets_received\f[R] - \f[I]packets_received\f[R] /
\f[I]server_packets_received\f[R]) (always present, but only valid if
\f[I]server_packets_received\f[R] is valid)
.IP \[bu] 2
\f[I]duplicate_percent\f[R] 100 * \f[I]duplicates\f[R] /
\f[I]packets_received\f[R]
.IP \[bu] 2
\f[I]late_packets_percent\f[R] 100 * \f[I]late_packets\f[R] /
\f[I]packets_received\f[R]
.IP \[bu] 2
\f[I]ipdv_send\f[R] a duration stats object for the send
IPDV (https://en.wikipedia.org/wiki/Packet_delay_variation) \f[B](only
available if server timestamps are enabled)\f[R]
.IP \[bu] 2
\f[I]ipdv_receive\f[R] a duration stats object for the receive
IPDV (https://en.wikipedia.org/wiki/Packet_delay_variation) \f[B](only
available if server timestamps are enabled)\f[R]
.IP \[bu] 2
\f[I]ipdv_round_trip\f[R] a duration stats object for the round-trip
IPDV (https://en.wikipedia.org/wiki/Packet_delay_variation)
\f[B](available regardless of whether server timestamps are enabled or
not)\f[R]
.IP \[bu] 2
\f[I]server_processing_time\f[R] a duration stats object for the time
the server took after it received the packet to when it sent the
response \f[B](only available when both send and receive timestamps are
enabled)\f[R]
.IP \[bu] 2
\f[I]timer_err_percent\f[R] the mean of the absolute values of the timer
error, as a percentage of the interval
.IP \[bu] 2
\f[I]timer_misses\f[R] the number of times the timer missed the interval
(was at least 50% over the scheduled time)
.IP \[bu] 2
\f[I]timer_miss_percent\f[R] 100 * \f[I]timer_misses\f[R] / expected
packets sent
.IP \[bu] 2
\f[I]send_rate\f[R] the send bitrate (bits-per-second and corresponding
string), calculated using the number of UDP payload bytes sent between
the time right before the first send call and the time right after the
last send call
.IP \[bu] 2
\f[I]receive_rate\f[R] the receive bitrate (bits-per-second and
corresponding string), calculated using the number of UDP payload bytes
received between the time right after the first receive call and the
time right after the last receive call
.SS round_trips
.PP
each round-trip is a single request to / reply from the server
.IP
.nf
\f[C]
\[dq]round_trips\[dq]: [
    {
        \[dq]seqno\[dq]: 0,
        \[dq]lost\[dq]: false,
        \[dq]timestamps\[dq]: {
            \[dq]client\[dq]: {
                \[dq]receive\[dq]: {
                    \[dq]wall\[dq]: 1508180723502871779,
                    \[dq]monotonic\[dq]: 2921143
                },
                \[dq]send\[dq]: {
                    \[dq]wall\[dq]: 1508180723502727340,
                    \[dq]monotonic\[dq]: 2776704
                }
            },
            \[dq]server\[dq]: {
                \[dq]receive\[dq]: {
                    \[dq]wall\[dq]: 1508180723502816623,
                    \[dq]monotonic\[dq]: 32644353327
                },
                \[dq]send\[dq]: {
                    \[dq]wall\[dq]: 1508180723502826602,
                    \[dq]monotonic\[dq]: 32644363306
                }
            }
        },
        \[dq]delay\[dq]: {
            \[dq]receive\[dq]: 45177,
            \[dq]rtt\[dq]: 134460,
            \[dq]send\[dq]: 89283
        },
        \[dq]ipdv\[dq]: {}
    },
    {
        \[dq]seqno\[dq]: 1,
        \[dq]lost\[dq]: false,
        \[dq]timestamps\[dq]: {
            \[dq]client\[dq]: {
                \[dq]receive\[dq]: {
                    \[dq]wall\[dq]: 1508180723702917735,
                    \[dq]monotonic\[dq]: 202967099
                },
                \[dq]send\[dq]: {
                    \[dq]wall\[dq]: 1508180723702807328,
                    \[dq]monotonic\[dq]: 202856692
                }
            },
            \[dq]server\[dq]: {
                \[dq]receive\[dq]: {
                    \[dq]wall\[dq]: 1508180723702861515,
                    \[dq]monotonic\[dq]: 32844398219
                },
                \[dq]send\[dq]: {
                    \[dq]wall\[dq]: 1508180723702872467,
                    \[dq]monotonic\[dq]: 32844409171
                }
            }
        },
        \[dq]delay\[dq]: {
            \[dq]receive\[dq]: 45268,
            \[dq]rtt\[dq]: 99455,
            \[dq]send\[dq]: 54187
        },
        \[dq]ipdv\[dq]: {
            \[dq]receive\[dq]: 91,
            \[dq]rtt\[dq]: -35005,
            \[dq]send\[dq]: -35096
        }
    },
    {
        \[dq]seqno\[dq]: 2,
        \[dq]lost\[dq]: true,
        \[dq]timestamps\[dq]: {
            \[dq]client\[dq]: {
                \[dq]receive\[dq]: {},
                \[dq]send\[dq]: {
                    \[dq]wall\[dq]: 1508180723902925971,
                    \[dq]monotonic\[dq]: 402975335
                }
            },
            \[dq]server\[dq]: {
                \[dq]receive\[dq]: {},
                \[dq]send\[dq]: {}
            }
        },
        \[dq]delay\[dq]: {},
        \[dq]ipdv\[dq]: {}
    }
]
\f[R]
.fi
.PP
\f[B]Note:\f[R] \f[I]wall\f[R] values are from Go\[cq]s
\f[I]time.Time.UnixNano()\f[R], the number of nanoseconds elapsed since
January 1, 1970 UTC
.PP
\f[B]Note:\f[R] \f[I]monotonic\f[R] values are the number of nanoseconds
since some arbitrary point in time, so can only be relied on to measure
duration
.IP \[bu] 2
\f[I]seqno\f[R] the sequence number
.IP \[bu] 2
\f[I]lost\f[R] the lost status of the packet, which can be one of
\f[I]false\f[R], \f[I]true\f[R], \f[I]true_down\f[R] or
\f[I]true_up\f[R].
The \f[I]true_down\f[R] and \f[I]true_up\f[R] values are only possible
if the \f[I]ReceivedStats\f[R] parameter includes
\f[I]ReceivedStatsWindow\f[R] (irtt client \f[I]--stats\f[R] flag).
Even then, if it could not be determined whether the packet was lost
upstream or downstream, the value \f[I]true\f[R] is used.
.IP \[bu] 2
\f[I]timestamps\f[R] the client and server timestamps
.RS 2
.IP \[bu] 2
\f[I]client\f[R] the client send and receive wall and monotonic
timestamps \f[B](\f[BI]receive\f[B] values only present if
\f[BI]lost\f[B] is false)\f[R]
.IP \[bu] 2
\f[I]server\f[R] the server send and receive wall and monotonic
timestamps \f[B](both \f[BI]send\f[B] and \f[BI]receive\f[B] values not
present if \f[BI]lost\f[B] is true)\f[R], and additionally:
.RS 2
.IP \[bu] 2
\f[I]send\f[R] values are not present if the StampAt (irtt client
\f[I]--tstamp\f[R] flag) does not include send timestamps
.IP \[bu] 2
\f[I]receive\f[R] values are not present if the StampAt (irtt client
\f[I]--tstamp\f[R] flag) does not include receive timestamps
.IP \[bu] 2
\f[I]wall\f[R] values are not present if the Clock (irtt client
\f[I]--clock\f[R] flag) does not include wall values or server
timestamps are not enabled
.IP \[bu] 2
\f[I]monotonic\f[R] values are not present if the Clock (irtt client
\f[I]--clock\f[R] flag) does not include monotonic values or server
timestamps are not enabled
.RE
.RE
.IP \[bu] 2
\f[I]delay\f[R] an object containing the delay values
.RS 2
.IP \[bu] 2
\f[I]receive\f[R] the one-way receive delay, in nanoseconds
\f[B](present only if server timestamps are enabled and at least one
wall clock value is available)\f[R]
.IP \[bu] 2
\f[I]rtt\f[R] the round-trip time, in nanoseconds, always present
.IP \[bu] 2
\f[I]send\f[R] the one-way send delay, in nanoseconds \f[B](present only
if server timestamps are enabled and at least one wall clock value is
available)\f[R]
.RE
.IP \[bu] 2
\f[I]ipdv\f[R] an object containing the
IPDV (https://en.wikipedia.org/wiki/Packet_delay_variation) values
\f[B](attributes present only for \f[BI]seqno\f[B] > 0, and if
\f[BI]lost\f[B] is \f[BI]false\f[B] for both the current and previous
\f[BI]round_trip\f[B])\f[R]
.RS 2
.IP \[bu] 2
\f[I]receive\f[R] the difference in receive delay relative to the
previous packet \f[B](present only if at least one server timestamp is
available)\f[R]
.IP \[bu] 2
\f[I]rtt\f[R] the difference in round-trip time relative to the previous
packet (always present for \f[I]seqno\f[R] > 0)
.IP \[bu] 2
\f[I]send\f[R] the difference in send delay relative to the previous
packet \f[B](present only if at least one server timestamp is
available)\f[R]
.RE
.SH EXIT STATUS
.PP
\f[I]irtt client\f[R] exits with one of the following status codes:
.PP
.TS
tab(@);
l l.
T{
Code
T}@T{
Meaning
T}
_
T{
0
T}@T{
Success
T}
T{
1
T}@T{
Runtime error
T}
T{
2
T}@T{
Command line error
T}
T{
3
T}@T{
Two interrupt signals received
T}
.TE
.SH WARNINGS
.PP
It is possible with the irtt client to dramatically harm network
performance by using intervals that are too low, particularly in
combination with large packet lengths.
Careful consideration should be given before using sub-millisecond
intervals, not only because of the impact on the network, but also
because:
.IP \[bu] 2
Timer accuracy at sub-millisecond intervals may begin to suffer without
the use of a custom kernel or the busy timer (which pins the CPU)
.IP \[bu] 2
Memory consumption for results storage and system CPU time both rise
rapidly
.IP \[bu] 2
The granularity of the results reported may very well not be required
.SH EXAMPLES
.TP
.B $ irtt client localhost
Sends requests once per second for one minute to localhost.
.TP
.B $ irtt client -i 200ms -d 10s -o - localhost
Sends requests every 0.2 sec for 10 seconds to localhost.
Writes JSON output to stdout.
.TP
.B $ irtt client -i 20ms -d 1m -l 172 --fill=rand --sfill=rand 192.168.100.10
Sends requests every 20ms for one minute to 192.168.100.10.
Fills both the client and server payload with random data.
This simulates a G.711 VoIP conversation, one of the most commonly used
codecs for VoIP as of this writing.
.TP
.B $ irtt client -i 0.1s -d 5s -6 --dscp=46 irtt.example.org
Sends requests with IPv6 every 100ms for 5 seconds to irtt.example.org.
Sets the DSCP value (ToS field) of requests and responses to 46
(Expedited Forwarding).
.TP
.B $ irtt client --hmac=secret -d 10s \[lq][2001:db8:8f::2/32]:64381\[rq]
Sends requests to the specified IPv6 IP on port 64381 every second for
10 seconds.
Adds an HMAC to each packet with the key \f[I]secret\f[R].
.SH SEE ALSO
.PP
irtt(1) (irtt.html), irtt-server(1) (irtt-server.html)
.PP
IRTT GitHub repository (https://github.com/heistp/irtt/)
